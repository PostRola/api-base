datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  previewFeatures = ["selectRelationCount", "orderByAggregateGroup"]
}


model EmailConfig {
  id            BigInt    @id @default(autoincrement())
  fromName      String    @map("from_name")
  fromEmail     String    @map("from_email")
  apiKey        String    @map("api_key")

  // Identifies the type of mail service - sendgrid, mailgun, mailchimp, etc.
  service       String

  @@map("email_config")
}


model ClientApp {
  id              String      @id @default(cuid())

  description     String

  secret          String
  hashFn          String      @map("hash_fn")

  createdAt       DateTime    @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt       DateTime    @db.Timestamptz() @updatedAt @map("updated_at")

  tokens          ClientAppToken[]

  @@map("client_app")
}


model ProjectType {
  // Though we do not really it need, using this
  // as a disjoint discriminant is really helpful
  // to ensure data integrity.
  id              String      @id
  description     String

  projects        Project[]
  roles           Role[]

  @@map("project_type")
}


model Project {
  id              BigInt          @id @default(autoincrement())
  name            String
  fromEmail       String          @map("from_email")

  type            ProjectType     @relation(fields: [projectType], references: [id])
  projectType     String          @map("project_type")

  publication     Publication?
  quota           Quota?
  assets          Asset[]
  invitations     Invitation[]
  users           User[]

  @@map("project")

  @@unique([id, projectType])
}


// Used to maintain the maximum size limits for uploaded assets and memberships
model Quota {
  id              BigInt      @id
  project         Project     @relation(fields: [id], references: [id])
  sizeInMB        Int         @map("size_in_mb")
  maxCapacity     Int         @map("max_capacity")
  occupied        Int

  // Note: Add the constraint where occupied <= maxCapacity
  @@map("quota")
}


model Invitation {
  id            BigInt        @id @default(autoincrement())
  code          String        @unique

  firstName     String        @map("first_name")
  lastName      String        @map("last_name")
  email         String

  // duration in milliseconds
  duration      Int
  expiryAt      DateTime      @db.Timestamptz() @map("expiry_at")

  project       Project       @relation(fields: [projectId, projectType], references: [id, projectType])
  projectId     BigInt        @map("project_id")
  projectType   String        @map("project_type")

  role          Role          @relation(fields: [roleId, projectType], references: [id, projectType])
  roleId        Int           @map("role_id")

  createdAt     DateTime      @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt     DateTime      @db.Timestamptz() @updatedAt @map("updated_at")

  @@map("invitation")
  @@unique(fields: [email, projectId])
}


model User {
  id                BigInt      @id @default(autoincrement())

  firstName         String      @map("first_name")
  lastName          String      @map("last_name")
  email             String

  password          String
  hashFn            String      @map("hash_fn")

  project           Project     @relation(fields: [projectId], references: [id])
  projectId         BigInt      @map("project_id")

  createdAt         DateTime    @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt         DateTime    @db.Timestamptz() @updatedAt @map("updated_at")

  role              UserRole?
  tokens            UserToken[]
  posts             Post[]
  resetRequest      ResetPasswordRequest?
  loginAttempt      LoginAttempt?

  @@map("app_user")
  @@unique([projectId, email])
}


model ClientAppToken {
  id              String      @id
  generatedAt     DateTime    @default(now()) @db.Timestamptz() @map("generated_at")

  // duration in milliseconds
  duration        Int

  clientApp       ClientApp   @relation(fields: [clientAppId], references: [id])
  clientAppId     String      @map("client_app_id")

  @@map("client_app_token")
}


model UserToken {
  id              String      @id

  generatedAt     DateTime    @default(now()) @db.Timestamptz() @map("generated_at")

  // duration in milliseconds
  duration        Int

  user            User        @relation(fields: [userId], references: [id])
  userId          BigInt      @map("user_id")

  @@map("user_token")
}


model ResetPasswordRequest {
  id          BigInt    @id @default(autoincrement())
  code        String    @unique
  user        User      @relation(fields: [userId], references: [id])
  userId      BigInt    @unique @map("user_id")

  createdAt   DateTime  @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt   DateTime  @db.Timestamptz() @updatedAt @map("updated_at")

  @@map("reset_password_request")
}


model LoginAttempt {
  user          User      @relation(fields: [userId], references: [id])
  userId        BigInt    @id @map("user_id")
  attempts      Int
  lastAttempt   DateTime  @db.Timestamptz() @updatedAt @map("last_attempt")

  @@map("login_attempt")
}


model Publication {
  id            BigInt        @id

  // Note: Add check constraint for the project type
  // to restrict project type to publication
  projectType   String        @map("project_type")

  project       Project       @relation(fields: [id, projectType], references: [id, projectType])
  publicUrl     String        @unique @map("public_url")

  posts         Post[]

  @@map("publication")
}


model UserRole {
  user            User            @relation(fields: [userId], references: [id])
  userId          BigInt          @id @map("user_id")

  role            Role            @relation(fields: [roleId], references: [id])
  roleId          Int             @map("role_id")

  @@map("user_role")
}


model Role {
  id              Int             @id
  name            String
  displayName     String          @map("display_name")

  scope           ProjectType     @relation(fields: [projectType], references: [id])
  projectType     String          @map("project_type")

  users           UserRole[]
  invitations     Invitation[]

  @@map("role")
  @@unique([id, projectType])
  @@unique([name, projectType])
}


model Tag {
  id            BigInt      @id @default(autoincrement())
  name          String
  slug          String      @unique()
  description   String
  approved      Boolean     @default(false)

  posts         PostTag[]

  createdAt     DateTime    @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt     DateTime    @db.Timestamptz() @updatedAt @map("updated_at")

  @@map("tag")
}


model Post {
  id              BigInt          @id @default(autoincrement())
  owner           User            @relation(fields: [ownerId], references: [id])
  ownerId         BigInt          @map("owner_id")

  slug            String
  canonicalUrl    String?         @map("canonical_url")

  publication     Publication     @relation(fields: [publicationId], references: [id])
  publicationId   BigInt          @map("publication_id")

  createdAt       DateTime        @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt       DateTime        @db.Timestamptz() @updatedAt @map("updated_at")
  publishedAt     DateTime?       @db.Timestamptz() @map("published_at")

  versions        PostVersion[]

  tags            PostTag[]
  postMeta        PostMeta?

  @@map("post")
  @@unique([publicationId, slug])
}


// Relationship is 1 --> 2
// One Post will have at max two versions.
model PostVersion {
  id              BigInt        @id @default(autoincrement())

  post            Post          @relation(fields: [postId], references: [id])
  postId          BigInt        @map("post_id")

  version         Int

  title           String
  content         Json          @db.JsonB

  postImage       PostImage[]

  @@map("post_version")
  @@unique([postId, version])
}


model PostMeta {
  id                BigInt      @id
  post              Post        @relation(fields: [id], references: [id])

  title             String
  description       String

  featuredImage     Image?      @relation(fields: [imageId], references: [id])
  imageId           BigInt?     @map("image_id")

  @@map("post_meta")
}


model PostTag {
  post      Post      @relation(fields: [postId], references: [id])
  postId    BigInt    @map("post_id")

  tag       Tag       @relation(fields: [tagId], references: [id])
  tagId     BigInt    @map("tag_id")

  order     Int

  @@map("post_tag")
  @@id([postId, tagId])
}


model AssetSource {
  id          Int       @id @default(autoincrement())

  // do, aws, azure, google
  cloudType   String    @map("cloud_type")

  // Region - Digital Ocean, AWS
  // Blank - Azure, Google (But still required to ensure uniqueness)
  region      String

  // Space - Digital Ocean
  // Bucket - AWS, Google
  // Container - Azure
  bucket      String

  publicUrl   String    @map("public_url")
  uploadUrl   String    @map("upload_url")

  // Connection string for azure
  key         String
  secret      String

  assets      Asset[]

  @@map("asset_source")
  @@unique([cloudType, region, bucket])
}


model Asset {
  id            BigInt        @id @default(autoincrement())

  source        AssetSource   @relation(fields: [sourceId], references: [id])
  sourceId      Int           @map("source_id")

  title         String
  fileName      String        @map("file_name") @unique()
  contentType   String        @map("content_type")

  size          Int
  sizeUnit      String        @map("size_unit")

  createdAt     DateTime      @db.Timestamptz() @default(now()) @map("created_at")
  updatedAt     DateTime      @db.Timestamptz() @updatedAt @map("updated_at")

  verified      Boolean       @default(false)

  project       Project       @relation(fields: [projectId], references: [id])
  projectId     BigInt        @map("project_id")

  image         Image?

  @@map("asset")
  @@index([sourceId])
}


model Image {
  id          BigInt      @id
  asset       Asset       @relation(fields: [id], references: [id])

  caption     Json        @db.JsonB
  altText     String      @map("alt_text")

  postImage   PostImage?
  postMeta    PostMeta[]

  @@map("image")
}


model PostImage {
  image         Image           @relation(fields: [imageId], references: [id])
  imageId       BigInt          @map("image_id")

  revision      PostVersion     @relation(fields: [revisionId], references: [id])
  revisionId    BigInt          @map("revision_id")

  @@id([imageId, revisionId])
  @@map("post_image")
}
